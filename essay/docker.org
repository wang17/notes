* docker
   - homepage: https://www.docker.com/
   - user guide: https://docs.docker.com/userguide/
   - 史上最全Docker资料集粹 : http://special.csdncms.csdn.net/BeDocker/

** introduction
   - https://www.docker.com/tryit/
   - https://code.csdn.net/u010702509/docker_ubntu

简单地说docker就是允许将应用运行所需要的环境打包，这样可以很容易地对应用进行分发以及部署。

docker有三种方式运行:
   - 作为一个守护进程来管理你的linux主机上的LXC容器（sudo docker -d）
   - 作为一个命令行的方式来告诉docker进程的程序接口来做什么（docker run ...）
   - 作为一个仓库的客户端让你分享你搭建的环境(docker pull,docker commit)

docker底层可以使用virtualbox(开销大，可以使用其他内核), 也可以使用lxc(轻量，必须使用本地内核). 如果使用lxc的话必须确保linux内核支持，使用下面命令来升级内核
#+BEGIN_EXAMPLE
#安装内核
sudo apt-get update
sudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring

#重启
sudo reboot
#+END_EXAMPLE

然后用apt-get命令来安装lxc-docker
#+BEGIN_EXAMPLE
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
sudo sh -c "echo deb http://get.docker.io/ubuntu docker main >/etc/apt/sources.list.d/docker.list"
sudo apt-get update
sudo apt-get install lxc-docker
#+END_EXAMPLE

docker使用cs架构，所以即使在本地运行也需要启动一个daemon的docker server进程
   - sudo service docker [command]
   - sudo docker -d &
默认server使用unix:///var/run/docker.sock做通信，因为这个文件owner是root，所以所有docker命令必须以sudo开头。所以修改这个文件的owner为普通用户的话就可以不用sudo开头。
（不过如果不使用默认值的话，那么所有docker命令都要添加-H来指定通讯方式，比较繁琐） 关于docker server命令可以man docker.

docker大部分使用方式都是集中在client上. 每个命令都有非常多的参数可以使用，可以man docker-<command>比如man docker-run察看

** commands
下面是docker client所有命令。大部分命令都是自描述的。
#+BEGIN_EXAMPLE
➜  docker  docker      
Usage: docker [OPTIONS] COMMAND [arg...]
 -H=[unix:///var/run/docker.sock]: tcp://host:port to bind/connect to or unix://path/to/socket to use

A self-sufficient runtime for linux containers.

Commands:
    attach    Attach to a running container
    build     Build an image from a Dockerfile
    commit    Create a new image from a container's changes
    cp        Copy files/folders from a container's filesystem to the host path
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    export    Stream the contents of a container as a tar archive
    history   Show the history of an image
    images    List images
    import    Create a new filesystem image from the contents of a tarball
    info      Display system-wide information
    inspect   Return low-level information on a container
    kill      Kill a running container
    load      Load an image from a tar archive
    login     Register or log in to the Docker registry server
    logs      Fetch the logs of a container
    port      Lookup the public-facing port that is NAT-ed to PRIVATE_PORT
    pause     Pause all processes within a container
    ps        List containers
    pull      Pull an image or a repository from a Docker registry server
    push      Push an image or a repository to a Docker registry server
    restart   Restart a running container
    rm        Remove one or more containers
    rmi       Remove one or more images
    run       Run a command in a new container
    save      Save an image to a tar archive
    search    Search for an image on the Docker Hub
    start     Start a stopped container
    stop      Stop a running container
    tag       Tag an image into a repository
    top       Lookup the running processes of a container
    unpause   Unpause a paused container
    version   Show the Docker version information
    wait      Block until a container stops, then print its exit code
#+END_EXAMPLE

命令基本可以分为操作container和image两类。container可以通过ID, NAME来定位。image可以通过ID, REPOSITORY:TAG来定位。
#+BEGIN_EXAMPLE
➜  wsrep-5.6  sudo docker ps -a                     
[sudo] password for dirlt: 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
84d4b4a3ad11        ubuntu:latest       /bin/bash           5 seconds ago       Up 5 seconds                            angry_nobel

➜  wsrep-5.6  sudo docker inspect 84d4b4a3ad11
[{
    "Args": [],
    "Config": {
        "AttachStderr": true,
        "AttachStdin": true,
        "AttachStdout": true,
        "Cmd": [
            "/bin/bash"
        ],
        "CpuShares": 0,
        "Cpuset": "",
        "Domainname": "",
        "Entrypoint": null,
        "Env": [
            "HOME=/",
            "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        ],
......

➜  wsrep-5.6  sudo docker images                    
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              latest              c4ff7513909d        3 days ago          225.4 MB
#+END_EXAMPLE
对于reposiroty名称约定是<username>/<image>. 如果不指定TAG只指定REPO的话，根据上下文结果会是REPO的最新一个TAG，或者是REPO下所有TAG。

comments on some commands
   - attach. 后台运行任务通常是非交互式的并且使用-d启动
   - history. 只能够察看本地image.
   - export/import. tarball里面文件都是single-layer所以可以用来创建全新的image.
   - save/load. 可以通过文件方式来传递image.

** docker-run
** docker-inspect
** Dockerfile
** FAQ
** troubleshooting
** internal stuff
   - LXC https://linuxcontainers.org/
   - AUFS http://en.wikipedia.org/wiki/Aufs

*** Understanding Docker
https://docs.docker.com/introduction/understanding-docker/

some images from "docker 原理簡介" http://blog.blackwhite.tw/2013/12/docker.html

Docker has two major components:
   - Docker: the open source container virtualization platform.
   - [[https://hub.docker.com/][Docker Hub]]: our Software-as-a-Service platform for sharing and managing Docker containers.

下面是docker架构图

file:./images/docker-architecture.svg

To understand Docker's internals, you need to know about three components:
   - Docker images. A Docker image is a read-only template. For example, an image could contain an Ubuntu operating system with Apache and your web application installed. Images are used to create Docker containers. Docker provides a simple way to build new images or update existing images, or you can download Docker images that other people have already created. Docker images are the build component of Docker.（应用执行所需环境的镜像，通常镜像是经过压缩的所以体积非常小）
   - Docker registries. Docker registries hold images. These are public or private stores from which you upload or download images. The public Docker registry is called [[http://hub.docker.com/][Docker Hub]]. It provides a huge collection of existing images for your use. These can be images you create yourself or you can use images that others have previously created. Docker registries are the distribution component of Docker.
   - Docker containers. Docker containers are similar to a directory. A Docker container holds everything that is needed for an application to run. Each container is created from a Docker image. Docker containers can be run, started, stopped, moved, and deleted. Each container is an isolated and secure application platform. Docker containers are the run component of Docker.（container就是应用执行所需环境，首先通过image创建出来一个完整的系统，然后允许在这个系统上安装应用程序以及读写文件。container最后可以打包成为image进行分发和部署）

-----

*How does a Docker Image work?*

We've already seen that Docker images are read-only templates from which Docker containers are launched. Each image consists of a series of layers. Docker makes use of [[http://en.wikipedia.org/wiki/UnionFS][union file systems]] to combine these layers into a single image. Union file systems allow files and directories of separate file systems, known as branches, to be transparently overlaid, forming a single coherent file system.（文件系统使用UFS，可以挂载多个文件系统然后提供统一视角，展现出一个整合之后的文件系统）

One of the reasons Docker is so lightweight is because of these layers. When you change a Docker image—for example, update an application to a new version— a new layer gets built. Thus, rather than replacing the whole image or entirely rebuilding, as you may do with a virtual machine, only that layer is added or updated. Now you don't need to distribute a whole new image, just the update, making distributing Docker images faster and simpler. （这也就是为什么读写image非常快，并且创建image体积非常小的原因。因为所有读写都不会影响base image, 只是操作单独的文件系统分支(layer)，同时在创建和发布新image时候只需要base image ID + diff即可。layer这个单词非常形象，这些image就是一层层layer叠加起来的）

Docker usually gets these base images from [[https://hub.docker.com/][Docker Hub]]. Docker images are then built from these base images using a simple, descriptive set of steps we call instructions. Each instruction creates a new layer in our image. Instructions include actions like: 1)Run a command. 2)Add a file or directory. 3)Create an environment variable. 4) What process to run when launching a container from this image. These instructions are stored in a file called a Dockerfile. Docker reads this Dockerfile when you request a build of an image, executes the instructions, and returns a final image. （创建image步骤都可以在Dockerfile里面指定）

file:./images/docker-filesystems-multilayer.png

-----

*How does a container work?*

A container consists of an operating system, user-added files, and meta-data. As we've seen, each container is built from an image. That image tells Docker what the container holds, what process to run when the container is launched, and a variety of other configuration data. The Docker image is read-only. When Docker runs a container from an image, it adds a read-write layer on top of the image (using a union file system as we saw earlier) in which your application can then run.（container包括操作系统，用户添加文件，以及元信息。创建container就是在image上面添加一层rw layer）

-----

*What happens when you run a container?*

Either by using the docker binary or via the API, the Docker client tells the Docker daemon to run a container.
#+BEGIN_EXAMPLE
$ docker run -i -t ubuntu /bin/bash
#+END_EXAMPLE
Let's break down this command. The Docker client is launched using the docker binary with the run option telling it to launch a new container. The bare minimum the Docker client needs to tell the Docker daemon to run the container is:（至少需要指定image, 以及运行command）
   - What Docker image to build the container from, here ubuntu, a base Ubuntu image;
   - The command you want to run inside the container when it is launched, here /bin/bash, to start the Bash shell inside the new container.
So what happens under the hood when we run this command? In order, Docker does the following:
   - Pulls the ubuntu image: Docker checks for the presence of the ubuntu image and, if it doesn't exist locally on the host, then Docker downloads it from Docker Hub. If the image already exists, then Docker uses it for the new container.
   - Creates a new container: Once Docker has the image, it uses it to create a container.
   - Allocates a filesystem and mounts a read-write layer: The container is created in the file system and a read-write layer is added to the image.
   - Allocates a network / bridge interface: Creates a network interface that allows the Docker container to talk to the local host.（创建网络接口）
   - Sets up an IP address: Finds and attaches an available IP address from a pool.（设置IP地址）
   - Executes a process that you specify: Runs your application, and;
   - Captures and provides application output: Connects and logs standard input, outputs and errors for you to see how your application is running.（观察日志）

-----

*The underlying technology*

Namespaces（名字空间）. Docker takes advantage of a technology called namespaces to provide the isolated workspace we call the container. When you run a container, Docker creates a set of namespaces for that container. This provides a layer of isolation: each aspect of a container runs in its own namespace and does not have access outside it. Some of the namespaces that Docker uses are:
   - The pid namespace: Used for process isolation (PID: Process ID).
   - The net namespace: Used for managing network interfaces (NET: Networking).
   - The ipc namespace: Used for managing access to IPC resources (IPC: InterProcess Communication).
   - The mnt namespace: Used for managing mount-points (MNT: Mount).
   - The uts namespace: Used for isolating kernel and version identifiers. (UTS: Unix Timesharing System).

file:./images/docker-namespace.png

Control groups（资源控制）. Docker also makes use of another technology called cgroups or control groups. A key to running applications in isolation is to have them only use the resources you want. This ensures containers are good multi-tenant citizens on a host. Control groups allow Docker to share available hardware resources to containers and, if required, set up limits and constraints. For example, limiting the memory available to a specific container.

Union file systems（UFS）. Union file systems, or UnionFS, are file systems that operate by creating layers, making them very lightweight and fast. Docker uses union file systems to provide the building blocks for containers. Docker can make use of several union file system variants including: AUFS, btrfs, vfs, and DeviceMapper.

Container format. Docker combines these components into a wrapper we call a container format. The default container format is called libcontainer. Docker also supports traditional Linux containers using LXC. In the future, Docker may support other container formats, for example, by integrating with BSD Jails or Solaris Zones.



